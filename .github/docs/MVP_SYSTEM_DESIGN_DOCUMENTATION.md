# Linkta System Design Documentation

## Table of Contents
1. [Introduction](#introduction)
2. [Requirements](#requirements)
3. [Constraints and Limitations](#constraints-and-limitations)
4. [System Architecture](#system-architecture)
5. [Technology Stack](#technology-stack)
6. [Data Design](#data-design)
7. [API Design](#api-design)
8. [Module Design](#module-design)
9. [Caching and Performance Optimization](#caching-and-performance-optimization)
10. [Error Handling and Logging](#error-handling-and-logging)
11. [Security Considerations](#security-considerations)
12. [Testing Strategy](#testing-strategy)
13. [Deployment and DevOps](#deployment-and-devops)
14. [Scalability and Performance](#scalability-and-performance)
15. [Maintenance and Support](#maintenance-and-support)
16. [Future Enhancements and Roadmap](#future-enhancements-and-roadmap)

## Introduction
### Overview
Linkta is an innovative e-learning platform that aims to address the challenges learners face in comprehending complex topics and grasping the interconnections within vast bodies of knowledge. In an era of information overload, Linkta empowers users by providing a visual interface to create personalized knowledge graphs (aka Linkta Flows) that establish hierarchies to uncover the hidden relationships between concepts.

### Purpose
The core functionality of Linkta revolves around transforming intricate subjects into interactive visual representations through the integration of natural language processing and intuitive user interactions. By leveraging these technologies, Linkta enables learners to navigate complex domains efficiently, filter out extraneous content, and focus on the most salient concepts and their relationships, facilitating a deeper understanding of the subject matter.

### Scope
This document outlines the system design for the Minimum Viable Product (MVP) of Linkta, detailing the architectural decisions, technical implementations, and design considerations required to bring this innovative learning solution to fruition.

### Objectives
By introducing visual metaphors and personalized knowledge graphs, Linkta aims to revolutionize the way individuals acquire, organize, and retain knowledge, empowering them to unlock their full learning potential and achieve a deeper comprehension of complex topics.

## Requirements
### Functional Requirements:
- **User Authentication and Authorization**
    - Implement support for email/password, OAuth and other single sign-on methods
    - Develop a "forgot password" functionality
    - Implement auth-guard for API endpoints
- **UserInput Submission and Processing**
    - Provide a mechanism for users to submit UserInput
    - Provide a mechanism to pre-process (sanitize, add context, reformat) UserInput
    - Provide a mechanism to interact with LLM to process UserInput and generate a LinktaFLow
    - Provide a mechanism to ensure the LinktaFLow generated by the LLM adheres to the desired format
    - Store UserInput and LinktaFLow in the database & return the LinktaFLow to the user
- **LinktaFlow Visualization and Interaction**
    - Provide a mechanism for users to visualize a LinktaFlow
    - Provide a mechanism for users to delete a LinktaFlow
    - Provide a mechanism for users to regenerate a new LinktaFlow
    - Provide a mechanism for users to update and version their LinktaFlow (e.g., save button or other appropriate mechanisms)
    - Node Interaction within a LinktaFlow:
        - Implement CRUD (Create, Read, Update, Delete) functionality for nodes
        - Develop basic drag-and-drop functionality for node movement
        - Implement visual feedback, such as node highlighting, on hover or selection
    - Provide undo/redo functionality to allow users to revert or re-apply changes made to LinktaFlows
- **User Management and Settings**
    - Provide a mechanism to retrieve and display LinktaFlows associated with a specific user
    - Provide a user settings mechanism that allows users to update their profile information and reset their password
    - Consider incorporating versioning for LinktaFlows within the user model to track and manage different versions of user-generated content (TBD)
- **Bug Reporting**
    - Implement a bug reporting mechanism that automatically creates bug tickets in the Linkta core repository

### Non-Functional Requirements:
- **Performance:** Fast response Efforts for API endpoints and optimized tree retrieval and rendering to reduce bounce rates.
- **Scalability:** Capable of handling an increasing number of users and data without performance degradation.
- **Security:** Robust authentication mechanisms, compliance with data privacy laws (GDPR, CCPA), and rate limiting to prevent abuse.
- **Reliability:** High system availability with minimal downEffort and robust error recovery mechanisms.
- **Maintainability:** Well-documented codebase adhering to coding standards, with a modular architecture for ease of updates.
- **Usability:** Intuitive user interface with straightforward onboarding processes.
- **Accessibility:** Compliance with WCAG guidelines.
- **Compatibility:** Functionality across various browsers and devices, particularly mobile.
- **Data Management:** Ensures data consistency and integrity, particularly for user-generated content.
- **Legal and Ethical Compliance:** Adherence to legal and ethical standards applicable to the software and its use.

## Constraints and Limitations
### Technical Constraints:
- **Tech Stack Integration:** Selected technologies must integrate seamlessly for low latency, high scalability, and robust security.
- **Cross-Platform Compatibility:** The system should be designed to support both web and potential future mobile applications, ensuring a consistent user experience across platforms.
### Resource Constraints:
- **Development Efficiency:** The development process must be efficient, leveraging the team's existing expertise with the MERN (MongoDB, Express, React, Node.js) stack within the constraints of a limited budget and Effortline.
- **Budget Limitations:** Due to financial constraints, strategic feature prioritization and efficient resource allocation are necessary to deliver a high-quality product within the allocated budget.
### Market Constraints:
- **Competitive Advantage:** To stand out in a competitive market, the Linkta system should offer unique features or superior performance compared to existing solutions.
- **Future Enhancements:** The system should be designed to accommodate future enhancements, including the integration of Retrieval-Augmented Generation (RAG) post-MVP, to enhance data processing and user interaction capabilities.

## System Architecture
Linkta employs a client-server architecture in a mono repo, facilitating interaction between the user-facing frontend and the server-side backend through a RESTful API.

The frontend is developed using React, incorporating various libraries to enhance interactivity and user experience. The backend is built on Node.js and Express, with Redis for caching and MongoDB for data persistence.

User authentication and authorization are managed through Firebase Authentication. The entire system is hosted on Google Cloud Platform (GCP) with Firebase Hosting.

### Architecture Diagram
>_Work in progress_

## Technology Stack
- **Programming Language:** TypeScript
- **Frontend:** React, Zustand, React Query, React Flow,  Radix UI
- **Backend:** Node.js, Express, Redis, MongoDB
- **LLM Provider**: Gemini (version TBD)
- **Auth Provider:** Firebase Authentication
- **DevOps/Infrastructure:** GCP, Firebase Hosting, GitHub Actions, Git
- **Testing:** Jest, React Testing Library, Cypress
- **Other:** Zod
- **Pending decisions:** Choice of notification library (React Toastify/React Hot Toast), logging library (Winston/Sentry), rate limiter, and monitoring and alerting tools

## Data Design
The detailed field-level information for each entity can be found in the "Data Design" section of the [API Design documentation](https://app.eraser.io/workspace/TCClWhuYjciANvj4k9Ab) and the [data design ER diagram](https://app.eraser.io/workspace/EJ7k7P8yiDQCqBUsEdoI).

## API Design
The detailed API endpoints, request/response formats, and authentication requirements can be found in the [API Design documentation](https://app.eraser.io/workspace/TCClWhuYjciANvj4k9Ab).

## Module Design
### User Interface Design:
The detailed view of the application's user interface, including wireframes and interactive prototypes can be found in the [Figma](https://www.figma.com/file/9QKsvDQ9jivgA9XfS0oqPd/Design-System---Linkta?type=design&node-id=691-3754&mode=design&t=kUnZmiidrbvSyFQ0-0).

### Modules:
#### UserInput Submission and Processing - Sprint 0
Story: As a user, I want to easily submit my input through an intuitive interface and have it processed securely into a structured LinktaFlow.

Design:
API & Data Design
- Design API for UserInput submission.
- Improve Data models for UserInput Model and LinktaFlow Model.
- Update API design documentation for UserInput submission and updated data design.

UI Design
- Update mockups for UserInput submission UI on Figma.

Frontend Design
- Update frontend design for UserInput submission.
    -  Estimated Effort: 2 hours.
    - Acceptance Criteria:
        - Frontend architecture and components are defined according to the mockups.
        - Data flow and state management are considered.
        - Frontend design is reviewed and approved by the team.

Frontend:
1. Provide UI for UserInput submission.
   - Estimated Effort: 6 hours.
   - Acceptance Criteria:
        - UI is implemented according to the mockups.
        - UI components are functional.
        - UserInput is captured and sent to the backend.
2. Implement loading state UI for user feedback during LLM processing.
   - Estimated Effort:6 hours.
   - Acceptance Criteria:
        - Loading state UI is displayed while waiting for LLM response.
        - User is informed about the processing status.
        - Loading state UI is dismissed when the response is received.
        - The design of the loading state UI aligns with Linkta's branding and visual style.
        - Colors, fonts, and iconography should match Linkta's design guidelines.
        - The loading state UI should be visually consistent with other UI components in the application.
        - The design should provide a seamless and intuitive user experience.
3. Implement toast notification component for user feedback.
   - Estimated Effort: 4 hours.
   - Acceptance Criteria:
        - Toast notification component is created.
        - Notifications are displayed for success and error states.
        - Notifications are dismissed automatically or on user interaction.
        - If toast notification library is used:
            - Ensure it is lightweight and easy to use.
            - Toast library is reviewed and approved by the team.
4. Implement client-side input validation and sanitization (*Implement with server-side input sanitization is highly recommended).
   - Estimated Hours: 4 hours.
   - Acceptance Criteria:
        - UserInput is validated before submission.
        - Invalid UserInput is prevented and appropriate error messages are displayed.
        - UserInput is sanitized to prevent security vulnerabilities with Zod.

Backend:
1. Improve API endpoint for receiving UserInput.
   - Estimated Effort: 2 hours.
   - Acceptance Criteria:
        - API endpoint is updated according to the design [Linkta API Design Documentation].
        - UserInput is received and validated.
        - Appropriate responses are returned based on the UserInput.
2. Implement server-side input sanitization for UserInput (*Implement with server-side input sanitization is highly recommended).
   - Estimated Effort: 2 hours.
   - Acceptance Criteria:
        - UserInput is sanitized on the server-side.

3. Improve pre-processing (add context, reformat) mechanism of UserInput.
   - Estimated Effort: 8 hours.
   - Acceptance Criteria:
        - Pre-processing mechanisms are improved.
        - User input is enriched with relevant context.
        - Input is reformatted to ensure compatibility with LLM.

4. Improve LLM interaction mechanism to process UserInput and generate a LinktaFlow.
   - Implement a mechanism to ensure the generated LinktaFlow adheres to the desired format.
   - Estimated Effort: 4 hours.
   - Acceptance Criteria:
        - Generated LinktaFlow is validated against the desired format.
        - Validation errors are handled gracefully.
        - LinktaFlow is formatted correctly before storage.

5. Handle sanitized UserInput and generated LinktaFlow storage in the database.
   - Estimated Effort: 2 hours.
   - Acceptance Criteria:
        - UserInput and LinktaFlow are stored securely in the database.
        - Data integrity is maintained.
        - Retrieval and querying of stored data are efficient.

#### LinktaFlow Visualization and Interaction - Sprint 1
>_Work in progress_

Story: As a user, I want to interactively visualize, update, and regenerate my LinktaFlows and perform CRUD operations on nodes.

Frontend:
1. Provide UI for users to visualize a LinktaFlow
2. Provide UI for users to update (name only) and delete a LinktaFlow
3. (TBD) Provide UI for users to view current UserInput and regenerate a new LinktaFlow
4. Provide UI for CRUD operations on nodes (Create, Update, Delete)
5. Implement basic drag-and-drop functionality for node movement
6. Implement visual feedback (node highlighting) on hover or selection
7. Implement undo/redo functionality to allow users to revert or re-apply changes made to LinktaFlow

Backend:
1. Implement API endpoints for retrieving, updating, and deleting a specific LinktaFlow
2. Handle LinktaFlow data manipulation and storage in the database
3. (TBD) Implement LinktaFlow versioning and history tracking

#### User Authentication and Authorization - Sprint 2
>_Work in progress_

Story: As a user, I want a secure and user-friendly authentication system to access my account and protected features.
Frontend:
1. Provide UI for user signup, login, password reset, and logout
2. Provide UI for OAuth Components
3. Provide UI for auth status indicators (loading spinner, toast for success or failure of auth actions)
4. Implement nav guard for protected routes and components
5. Setup and initialize Firebase auth
6. (TBD) Implement email verification

Backend:
1. Setup Firebase Admin SDK
2. Handle token verification
3. Implement auth-guard for API endpoints
4. (TBD) Implement API endpoint for authentication
5. (TBD) Implement API endpoint for session login and logout
6. (TBD) Handle session management

#### User Management and Settings - Sprint 3
> Work in progress

Story: As a user, I want to manage my LinktaFlows, update my profile, and customize settings in a dedicated management area

Frontend:
1. Provide UI to display all LinktaFlows associated with a specific user
2. Provide UI for users to update (name only) and delete a LinktaFlow
3. Provide UI for user settings
4. Provide UI for updating user information and resetting the password

Backend:
1. Implement API endpoint for retrieving all LinktaFlows associated with a user
2. Implement API endpoints for retrieving, updating, and deleting user profile
3. Integrate with Firebase Authentication for password reset functionality
4. Handle user data manipulation and storage in MongoDB
5. (TBD) Implement LinktaFlow versioning and history tracking within the user model

#### Bug Reporting - Sprint 4
Story: As a user, I want a simple way to report bugs or issues to contribute to the continuous improvement of the platform

Frontend:
1. Provide UI for bug report submission

Backend:
1. Implement API endpoint for receiving bug reports
2. Implement functionality to automatically create bug tickets in the Linkta core repository

#### Infrastructure and DevOps
1. Continuous Integration and Deployment (CI/CD) Pipeline: Automates the build, testing, and deployment processes using GitHub Actions and Firebase Hosting.
2. Monitoring and Alerting: Implements monitoring and alerting solutions to track application performance, error rates, and system health.
3. Cloud Infrastructure: Provisions and manages the necessary cloud resources (e.g., virtual machines, load balancers, databases) on Google Cloud Platform (GCP).

#### Cross-Cutting Concerns
1. Logging and Error Handling: Implements a centralized logging system and robust error-handling mechanisms.
2. Performance Optimization: Employs techniques like caching, load balancing, and database indexing to ensure optimal performance.
3. Security and Compliance: Implements security best practices, such as input validation, rate limiting, and adherence to data privacy regulations (GDPR, CCPA).

## Caching and Performance Optimization
>_Work in progress_

## Error Handling and Logging
>_Work in progress_

## Security Considerations
- **Authentication and Authorization:** Firebase Authentication is used for user authentication and authorization. API endpoints are protected and require valid session tokens for access.
- **Data Privacy:** The system will be designed to comply with relevant data privacy laws such as GDPR and CCPA.
- **Rate Limiting:** Rate limiting mechanisms will be implemented to prevent abuse and protect against excessive requests.
- **Secure Communication:** HTTPS will be used for all client-server communications to ensure data confidentiality and integrity.

## Testing Strategy
- **Unit Testing:** Individual components and modules will be tested using Jest, React Testing Library to ensure they function as expected in isolation.
- **Integration Testing:** Integration tests will be performed to verify the proper functioning of component interactions and workflows.
- **End-to-End Testing:** Cypress will be used for end-to-end testing to simulate user interactions and validate the system's behavior from the user's perspective.
> To be decided:
**Performance and Load Testing:** Performance and load testing will be conducted to identify performance bottlenecks, optimize code, and ensure the application can handle expected user traffic.
**Accessibility Testing:** Accessibility testing will be performed to ensure the application adheres to WCAG accessibility guidelines, including testing for keyboard navigation, color contrast, and screen reader compatibility.
**Security Testing:** Security testing, including penetration testing and vulnerability scanning, will be conducted to identify and mitigate security risks. Security best practices, such as input validation, rate limiting, and secure headers, will be implemented.

**Key Component Testing**
>_Work in progress_

**User Authentication and Authorization**
- Test user authentication flow (signup, login, logout, password reset) with Firebase Authentication
- Test OAuth integration with Firebase Authentication
- Test Firebase ID token verification for securing API endpoints
- Test authorization mechanisms and access to protected routes/components

**UserInput Submission and Processing**
- Test server-side input sanitization
- Test LLM integration for processing UserInput and generating LinktaFlow
- Test the mechanism to ensure the generated LinktaFlow adheres to the desired format
- Test storage and retrieval of UserInput and generated LinktaFlow
- End-to-end testing of UserInput submission, processing, and LinktaFlow generation flow

**LinktaFlow Visualization and Interaction**
- Test CRUD operations for nodes (Create, Update, Delete)
- Test drag-and-drop functionality for node movement
- Test visual feedback (node highlighting) on hover or selection
- Test integration between frontend and backend for LinktaFlow visualization and interaction
- End-to-end testing of user interactions with LinktaFlow visualization (node creation, update, deletion, drag-and-drop)

**User Management and Settings**
- Test retrieval of LinktaFlows associated with a user
- Test updating user profile information with Firebase Authentication
- Test integration between frontend and backend for retrieving and updating user information and LinktaFlows
- End-to-end testing of user flows for managing LinktaFlows and updating profile

## Deployment and DevOps
- **Deployment:** Linkta will be deployed on Google Cloud Platform (GCP) using Firebase Hosting.
- **Continuous Integration and Continuous Deployment (CI/CD):** GitHub Actions will be utilized to automate the build, testing, and deployment processes.

## Scalability and Performance
>_Work in progress_

## Maintenance and Support
>_Work in progress_

## Future Enhancements and Roadmap
>_Work in progress_