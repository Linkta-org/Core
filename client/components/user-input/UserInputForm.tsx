import React, { useEffect } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import { useMutation } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  TextField,
  Button,
  FormControlLabel,
  Box,
  Typography,
  Checkbox,
} from '@mui/material';
import userInputValidationSchema from '@zod/validateUserInput';
import styles from '@styles/UserInputView.module.css';
import { MOCK_USER_ID } from '@/mocks';

interface UserInputPayload {
  input: string;
}

const UserInputForm = () => {
  // Here we utilize the useForm hook's properties to manage form state while also initializing default values and resolving our validation schema.
  // The control object is used by react-hook-form's Controller to link our UserInputBar and UserInputCheckbox components to the form's state, handling any necessary state updates or validation checks.
  const {
    handleSubmit,
    reset,
    control,
    watch,
    formState: { errors, isSubmitted },
  } = useForm({
    resolver: zodResolver(userInputValidationSchema),
    defaultValues: {
      input: '',
      isChecked: JSON.parse(localStorage.getItem('isChecked') || 'false'),
    },
  });
  const navigate = useNavigate();

  // Here we utilize the watch function to subscribe to checkbox state changes and save those changes to our localStorage.
  useEffect(() => {
    const subscription = watch((value, { name }) => {
      if (name === 'isChecked') {
        localStorage.setItem('isChecked', value.isChecked);
      }
    });
    return () => subscription.unsubscribe();
  }, [watch]);

  const newUserInputMutation = useMutation({
    mutationFn: async (userInput: UserInputPayload) => {
      const uniqueRequestId = crypto.randomUUID();

      const response = await axios.post(
        'http://localhost:3000/v1/inputs',
        {
          input: userInput.input,
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-user-id': MOCK_USER_ID,
            'x-request-id': uniqueRequestId,
          },
        }
      );
      return response.data;
    },
    // TODO: underscore added to var to signal to eslint that it is intentionally unused for now. Remove when variable is properly used.
    onSuccess: (_data) => {
      // console.log('UserInput sent successfully', _data);
      reset();
      navigate('/output');
    },
    // TODO: underscore added to var to signal to eslint that it is intentionally unused for now. Remove when variable is properly used.
    onError: (_error) => {
      // TODO: implement logging service
      // console.error('Error sending prompt: ', _error);
    },
  });

  const onSubmit = (userInput: UserInputPayload) => {
    newUserInputMutation.mutate({ input: userInput.input });
  };

  return (
    <>
      <form
        onSubmit={handleSubmit(onSubmit)}
        className={`${styles.userInputForm}`}
      >
        <Typography
          className={`${styles.userInputFormTitle}`}
          variant="h6"
          sx={{ textAlign: 'left', color: 'text.primary', mb: 2 }}
        >
          Start your learning journey here:
        </Typography>

        <Box className={`${styles.inputsContainer}`}>
          <Controller
            name="input"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                variant="outlined"
                className={`${styles.userInputTextField}`}
                error={!!errors.input}
                helperText={errors.input ? errors.input.message : ''}
              />
            )}
          />

          <FormControlLabel
            className={`${styles.userInputDisclaimer}`}
            label="Content on this site may be generated by artifical intelligence (AI). Please use discretion and verify information where necessary."
            sx={{ color: 'text.primary' }}
            control={
              <Controller
                name="isChecked"
                control={control}
                render={({ field }) => (
                  <Checkbox
                    className={`${styles.UserInputCheckbox}`}
                    {...field}
                    checked={field.value}
                  />
                )}
              />
            }
          />
        </Box>

        <Button
          variant="contained"
          className={`${styles.userInputSubmitButton}`}
          type="submit"
          disabled={isSubmitted || !control._formValues.isChecked}
        >
          Generate
        </Button>
      </form>
    </>
  );
};

export default UserInputForm;
